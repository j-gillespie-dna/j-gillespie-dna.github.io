[["index.html", "A Gentle Introduction to Spatial Transcriptomics Analysis Chapter 1 Welcome! 1.1 Who is this NOT for 1.2 So who is this actually for then? 1.3 Want to contribute? 1.4 About this actual site", " A Gentle Introduction to Spatial Transcriptomics Analysis Jessica Gillespie 2025-04-09 Chapter 1 Welcome! This started as part of my masters thesis but has been continued as a way to provide some guidance to all of those trying to teach themselves a new NGS analysis techniques. If you would like to download the files used to create this protocol (including the figures) check out the GitHub 1.1 Who is this NOT for This protocol is not for anyone with extensive ST analysis experience. We will not be discussing intricate details or highly technical aspects beyond general notes to new users or “tips and tricks”. Conversely, this protocol is also not for someone completely new to next-generation sequencing (NGS), bioinformatics (BMI) analysis, or R. We will not be covering in detail datatypes, file handling, basic biological concepts involved with ST samples, or ST concepts prior to completed sequencing. There are places to find such information and repeating them here would be redundant and beyond the scope of this project. Instead, two good resources are W3Schools which will teach you the very basics of R and DataQuest which has more basics and also some simple projects where you can practice coding. 1.2 So who is this actually for then? The idea of this protocol is to run someone through their “first time” doing spatial transcriptomics analysis. Maybe you want to see if this is a new experiment type you would like to pursue in your lab. Maybe you just want to dabble in a new method to expand your BMI repertoire. If you want to take a simple data set and get a small hands-on experience with ST analysis, this is for you. 1.3 Want to contribute? The world of ST analysis is ever changing and constantly expanding. There is no guarantee this page or project will contain the most up to date information. This project is also currently managed by a single person in their spare time. If you would like to make updates, corrections, report problems, or suggest improvements, please feel free to do so using the issue tracker or discussion boards here on github or (if you are comfortable with git and coding) contributing directly to the repository. There are several plans for the expansion of this protocol and they will be implemented as time allows. However, I hope you find this project helpful and informative in its current state. 1.4 About this actual site These pages are all written in R using a package called Bookdown. This package allows you to write R scripts that can then be converted into html files. These files can then be uploaded to GitHub and published via GitPages. The R files are available for download on GitHub if you want a “behind the scenes” view of these pages or you want to run them without copy/pasting code from these pages. At the bottom of every chapter, you will see output from sessionInfo(). This is a command in R that prints a list of current R environment infomration as well as packages that were loaded at the time of creating this page. While it is not necessary if you are creating simple webpages like this one, it is provided as part of the protocol as it can be useful in troubleshooting. sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] digest_0.6.37 R6_2.6.1 bookdown_0.42 fastmap_1.2.0 ## [5] xfun_0.51 cachem_1.1.0 knitr_1.49 htmltools_0.5.8.1 ## [9] rmarkdown_2.29 lifecycle_1.0.4 cli_3.6.4 sass_0.4.9 ## [13] jquerylib_0.1.4 compiler_4.4.3 rstudioapi_0.17.1 tools_4.4.3 ## [17] evaluate_1.0.3 bslib_0.9.0 yaml_2.3.10 jsonlite_1.9.0 ## [21] rlang_1.1.5 "],["introduction.html", "Chapter 2 Introduction 2.1 General Workflow", " Chapter 2 Introduction As biological technologies continue to advance, analysis methods that bring novel insight to the field are rapidly developing, including new ways to use already familiar techniques. RNA sequencing (RNA-seq) began with bulk methods that averaged expression across a sample. The next iteration used dissociation to disrupt tissue into single cells that could be sequenced individually (single-cell RNA-seq; scRNA-seq) to inform which genes were expressed in tandem in the same cell. Most recently, spatial information has been added to the analysis so now gene expression across a tissue sample can be reconstructed to give a 2D (or even 3D) picture. This new field is called spatial transcriptomics (ST). ST analysis has a wide variety of applications. Starting at the sub-cellular level, imaging methods are able to localize RNA to specific parts of a cell to illuminate the structured handling of gene expression. At the cellular level, the distance between cells and the expression of ligand-receptor pairs are used to predict possible cell communication with greater accuracy. Finally, tissue-level datasets can inform the cellular makeup of a tumor sample or allow us to create a highly detailed tissue atlas with incredible resolution. There are several methods for capturing RNA expression and spatial information from a tissue sample, one of the more popular options being 10X Genomics’ Visium platform. The Visium platform allows for capture of close to single-cell resolution whole transcriptome RNA-seq data while also noting the spatial position of cells in a tissue. Briefly, fresh frozen or formalin-fixed paraffin-embedded (FFPE) samples are fixed to a slide and stained with immunofluorescent (IF) markers or Hematoxylin and Eosin (H&amp;E) stain before the slide is imaged. Tissue on the slide is then hybridized with whole-transcriptome probes and the slide is placed into a 10X Genomics CytAssist machine where areas of the tissue are captured and sequenced. Genomics’ Space Ranger software then converts raw data into an expression matrix and spatial coordinates. This platform is currently a popular choice and therefore this protocol will focus on analyzing data collected this way. Although ST analysis pipelines may involve numerous steps, this chapter highlights three core components that are consistently implemented in widely used workflows.. The first is clustering which uses spatial and RNA-seq data to group sequencing spots by common gene expression profiles. These clusters can then inform tissue architecture and be used for spatial domain prediction. Next, spatially variable gene expression detection highlights which genes may vary in expression by location revealing structural domains or tissue heterogeneity. Cell-cell communication allows for the prediction of communication networks across a sample by assessing the distance between expression of ligand-receptor pairs in cells. This protocol will focus on ST analysis with the three steps mentioned above. The software used at each step is one of a myriad of options and was chosen for ideal dataflow and ease of use. All are available as R packages therefore a familiarity with basic R functionality such as installing and loading R packages, handling R datatypes, and loading and saving data in R is advised. 2.1 General Workflow The figure below shows the general workflow of this pipeline along with the software for each step. The workflow is presented linearly here although the steps after clustering may be done in any order and several are optional depending on the desired analysis. sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] digest_0.6.37 R6_2.6.1 bookdown_0.42 fastmap_1.2.0 ## [5] xfun_0.51 cachem_1.1.0 knitr_1.49 htmltools_0.5.8.1 ## [9] rmarkdown_2.29 lifecycle_1.0.4 cli_3.6.4 sass_0.4.9 ## [13] jquerylib_0.1.4 compiler_4.4.3 rstudioapi_0.17.1 tools_4.4.3 ## [17] evaluate_1.0.3 bslib_0.9.0 yaml_2.3.10 jsonlite_1.9.0 ## [21] rlang_1.1.5 "],["materials.html", "Chapter 3 Materials 3.1 Computer Infrastructure 3.2 Software 3.3 Collect necessary files", " Chapter 3 Materials 3.1 Computer Infrastructure As R will be the main working environment any operating system capable of running R is sufficient. ST datasets can be quite large (10’s of GB) and saving data at several stages in the process may be desired so 10-20GB of space may be desired. A multi-core processor for faster analysis may be beneficial at some steps, though not required. Finally, a fairly large amount of RAM may be required (&gt;16GB). High Performance Computing services are available allowing users to analyze their data on a cluster, although that procedure is not detailed here. 3.2 Software R is the coding environment in which the analysis will take place. R can be run via the command-line or used in the RStudio GUI. Packages can then be installed from within R. Version numbers used in this protocol are provided but these specific versions are not mandatory. R (v4.4.2) RStudio (RStudio 2024.12.0+467 “Kousa Dogwood”) Seurat (v5.2.0) SPARK-X CellChat (v2.1.0) 3.3 Collect necessary files 3.3.1 Space Ranger output After sequencing is completed, 10X Visium data will be provided as either base call files (.BCL) or FASTQ files, either of which can be used for input to 10X Genomics’ Space Ranger software. The output of Space Ranger is the input for our first analysis method so we will start there. Space Ranger provides a variety of files containing data and various metrics on the samples and sequencing run. We are interested in one file and one folder. We need the filtered feature-barcode matrices: hdf5 which holds the barcodes, features, and RNA count data. We will also need the spatial folder which contains data pertaining to the image that accompanies the sample. For a full picture of output file structure, see the 10X Genomics website. 3.3.2 Reference data In order to mark cell types, we need to compare gene expression to that of already determined cells. This is frequently done with a reference dataset. While the software mentioned here has some reference sets built in, there are others available for download. These can be used after the clustering step for cell-type annotation and in deconvolution. Some annotated datasets are available from the HuBMAP Consortium. 3.3.3 Example datasets 10X Genomics has freely available many datasets produced with their technology for users to download and analyze. These are useful for practice and learning. A mouse anterior brain dataset will be used in this chapter and is available here. NOTE: If you click this link from an institution’s network you will be asked to sign up for an account. However, if you click this link from a home network, you won’t have to provide an email to download a free dataset. To follow along with this tutorial After clicking the link, scroll down on the page and click on “Output and supplemental files”. Download the “Feature / barcode matrix HDF5 (filtered)” and place it in the datasets folder. Also download the “Spatial imagine data”, a compressed folder named “V1_Mouse_Brain_Sagittal_Anterior_Section_2_spatial.tar.gz” into the dtasets folder. Extracting this should give you a folder named spatial with various files inside. Leave this as is for now. sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] digest_0.6.37 R6_2.6.1 bookdown_0.42 fastmap_1.2.0 ## [5] xfun_0.51 cachem_1.1.0 knitr_1.49 htmltools_0.5.8.1 ## [9] rmarkdown_2.29 lifecycle_1.0.4 cli_3.6.4 sass_0.4.9 ## [13] jquerylib_0.1.4 compiler_4.4.3 rstudioapi_0.17.1 tools_4.4.3 ## [17] evaluate_1.0.3 bslib_0.9.0 yaml_2.3.10 jsonlite_1.9.0 ## [21] rlang_1.1.5 "],["qc-clustering-and-annotating-with-seurat.html", "Chapter 4 QC, Clustering, and Annotating with Seurat 4.1 Importing and QC 4.2 Visualizing Gene Expression 4.3 Dimention Reduction and Clustering 4.4 Visualizing Clusters 4.5 Spot Annotating 4.6 Saving the data", " Chapter 4 QC, Clustering, and Annotating with Seurat First, we will import the necessary Space Ranger output and perform some QC on the gene expression data. Then the gene expression and spatial data will be used to group (cluster) cells. Finally, we will annotate the clusters by cell type. Let’s load the necessary libraries. rm(list = ls()) # This clears your environment of any variables there. We do #this to keep things tidy. library(ggplot2) library(ggpubr) library(cowplot) library(patchwork) library(dplyr) source(&quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_wrapper.R&quot;); library(HGNChelper) library(Seurat) # Easy to change variables for our project folder structure data_dir &lt;- &quot;datasets&quot; figs_dir &lt;- &quot;figures&quot; # This sets to the size of figures in inches two_panel = 3.5 one_pnael = two_panel/2 # We can do automatic figure numbering. We start with 2 as the flowchart is figure 1 fig_num = 1 4.1 Importing and QC 4.1.1 Load in the data A Seurat object must first be constructed from the hdf5 file and spatial folder. This object is a special data type, holding all of the information about the sample and any additional information as a result of the analyses performed here. Image data can be read from the spatial folder via the Read10X_Image command and stored as a variable. This variable can then be used in the Load10X_Spatial command along with the hdf5 filename to load the data. mouse_h5 &lt;- &quot;V1_Mouse_Brain_Sagittal_Anterior_Section_2_filtered_feature_bc_matrix.h5&quot; mouse_image &lt;- Read10X_Image(image.dir = paste0(data_dir, &quot;/spatial&quot;)) brain_ant &lt;- Load10X_Spatial(data.dir = data_dir, filename = mouse_h5, assay = &quot;Spatial&quot;, image = mouse_image) 4.1.2 Trim and filter A few plots may be viewed for quick data exploration. The VlnPlot and SpatialFeaturePlot functions with the nCount_Spatial option display the distribution of spatial features in the sample. This demonstrates that molecular counts vary across the sample as a result of technical variations but also tissue type. We may want to remove feature counts that are exceptionally low or extremely high. Using the PercentageFeaturesSet command with a pattern matching “^mt-” (often the designation for mitochondrial RNA) and a VlnPlot selected for this feature allows us to visualize the percentage mitochondrial RNA counts in samples. It is suggested to eliminate cells with high amounts of mitochondrial RNA as this will contribute noise to expression data. There is no definitive rule or cutoffs for this step and largely depends on the researcher’s evaluation of the data. brain_ant[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(brain_ant, pattern = &quot;^mt-&quot;) figa &lt;- VlnPlot(brain_ant, features = &quot;nCount_Spatial&quot;, pt.size = 0.1) + NoLegend() + labs(title = &quot;A. Features Violin Plot&quot;, y = &quot;Count&quot;) + theme(axis.title.x = element_blank(), axis.text.x = element_blank(), plot.title = element_text(size = 10), text = element_text(family = &quot;Helvetica&quot;)) figb &lt;- SpatialFeaturePlot(brain_ant, features = &quot;nCount_Spatial&quot;) + labs(title = &quot;Features Spatial Plot&quot;) + theme(legend.position = &quot;right&quot;, plot.title = element_text(size = 16), text = element_text(family = &quot;Helvetica&quot;)) figc &lt;- VlnPlot(brain_ant, features = &quot;percent.mt&quot;) + NoLegend() + labs(title = &quot;B. Percent Mitochondrial Violin Plot&quot;, y = &quot;Percentage&quot;) + theme(axis.title.x = element_blank(), axis.text.x = element_blank(), plot.title = element_text(size = 10), text = element_text(family = &quot;Helvetica&quot;)) wrap_plots(figa, figb) figc ggsave(filename = paste0(figs_dir, &quot;/Figure_clust_&quot;, fig_num, &quot;.png&quot;), plot = wrap_plots(figa, figb, figc), units = &quot;in&quot;, width = two_panel * (7/4), height = two_panel, dpi = 300) fig_num = fig_num + 1 Based on the plots above, we use the subset function to select samples with a mitochondrial percent &lt; 30 and a feature count &lt; 50,000. brain_ant &lt;- subset(brain_ant, subset = percent.mt &lt; 30 &amp; nCount_Spatial &lt; 50000) 4.1.3 Normalization Next we need to normalize the data using SCTransform. Normalization is a common step to remove from samples technical variation that may interfere with downstream analsysis. Many normalization methods exist, most often log normalization is used with RNA-seq. Log normalization assumes all cells have the same number of RNA molecules, which is often far from the case and would therefore require more steps to account for this assumption. Seurat has its own method called SCTransform which combines the normalization and correction steps into a single command. brain_ant &lt;- SCTransform(brain_ant, assay = &quot;Spatial&quot;, verbose = FALSE) 4.2 Visualizing Gene Expression Now that we have normalized gene expression, we can visualize this on the tissue sample image. Depending on the tissue under study and our goals, it may be interesting to pick a marker that can distinguish the anatomical structure of the sample. This plot overlays the expression of chosen genes over the provided tissue H&amp;E image. We can see that the expression is not heterogeneous for all genes. In the next section, we will use a method to find out which expressions vary significantly across the tissue. Note, these images are ggplot images and can therefore be customized using ggplot options. fig &lt;- SpatialFeaturePlot(brain_ant, features = c(&quot;Hpca&quot;, &quot;Ttr&quot;)) &amp; theme(plot.title = element_text(size = 16, hjust = &quot;left&quot;), text = element_text(family = &quot;Helvetica&quot;)) fig ggsave(filename = paste0(figs_dir, &quot;/Figure_clust_&quot;, fig_num, &quot;.png&quot;), plot = fig, units = &quot;in&quot;, width = two_panel * (7/4), height = two_panel, dpi = 300) fig_num = fig_num + 1 4.3 Dimention Reduction and Clustering When clustering, any number of variables can be considered. However, it is not necessary to include ALL variables as some contribute very little overall or even add noise. Dimension reduction pairs down the parameter list to only those that contribute meaningfully to the analysis. This is achieved here by using RunPCA on the transformed data. Now we can group cells using FindNeighbors, FindClusters, and RunUMAP. Briefly, Seurat uses a graph-based approach to clustering starting with a K-Nearest Neighbors graph based on the PCA space, then uses a Louvian algorithm to cluster the cells before a final non-linear dimensional reduction is performed with UMAP. brain_ant &lt;- RunPCA(brain_ant, assay = &quot;SCT&quot;, verbose = FALSE) brain_ant &lt;- FindNeighbors(brain_ant, reduction = &quot;pca&quot;, dims = 1:30) ## Computing nearest neighbor graph ## Computing SNN brain_ant &lt;- FindClusters(brain_ant, verbose = FALSE) brain_ant &lt;- RunUMAP(brain_ant, reduction = &quot;pca&quot;, dims = 1:30) ## 11:55:42 UMAP embedding parameters a = 0.9922 b = 1.112 ## 11:55:42 Read 2779 rows and found 30 numeric columns ## 11:55:42 Using Annoy for neighbor search, n_neighbors = 30 ## 11:55:42 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 11:55:42 Writing NN index file to temp file /tmp/Rtmp9odOJO/fileab8976572a8d ## 11:55:42 Searching Annoy index using 1 thread, search_k = 3000 ## 11:55:43 Annoy recall = 100% ## 11:55:43 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 11:55:44 Initializing from normalized Laplacian + noise (using RSpectra) ## 11:55:44 Commencing optimization for 500 epochs, with 109402 positive edges ## 11:55:44 Using rng type: pcg ## 11:55:47 Optimization finished 4.4 Visualizing Clusters There are a few options for visualization of our clusters. First, a traditional UMAP plot showing our clustering results with this DimPlot function. SpatialDimPlot will show the distribution of identified clusters by overlaying them onto our tissue image. Giving SpatialDimPlot a few cluster identities allows us to highlight the location of selected clusters. Again, these are ggplot objects that can be customized using the ggplot2 package. figa &lt;- DimPlot(brain_ant, reduction = &quot;umap&quot;, label = TRUE) + labs(title = &quot;A&quot;) + theme(text = element_text(family = &quot;Helvetica&quot;), plot.title = element_text(face = &quot;plain&quot;)) figb1 &lt;-SpatialDimPlot(brain_ant, label = TRUE, label.size = 3) + labs(title = &quot;B&quot;, fill = &quot;Cluster&quot;) + theme(text = element_text(family = &quot;Helvetica&quot;)) + NoLegend() figb2 &lt;- SpatialDimPlot(brain_ant, cells.highlight = CellsByIdentities(object = brain_ant, idents = c(0,8)), facet.highlight = TRUE, ncol = 1) figb &lt;- wrap_plots(figb1, figb2) wrap_plots(figa, figb, ncol = 1) ggsave(filename = paste0(figs_dir, &quot;/Figure_clust_&quot;, fig_num, &quot;.png&quot;), plot = wrap_plots(figa, figb, ncol = 1), units = &quot;in&quot;, width = two_panel * (7/4), height = two_panel * 2, dpi = 300) fig_num = fig_num + 1 4.5 Spot Annotating A final step required is to annotate our clusters by assigning them cell types. This process is not single-cell resolution as our clusters consist of “spots” that contain several cells each (a characteristic of the 10X Visium platform used here). Deconvolution is needed to estimate individual cell types in each spot and is a separate step. While there are automated methods to do this, they are far from perfect, and the best way to annotate your samples is to have domain knowledge of markers that indicate cell types. If particular markers are known, expression can be viewed by cluster via a violin plot to assist in confirming. Several methods exist to perform this step. SingleR with celldex is a popular method. Another method is Azimuth. Here, we will use Sc-Type. The run_sctype function has built-in references if we provide “Brain” as the tissue type. Note that this reference is currently only for human tissue so the match will not be perfect for our data here. We can then show the new cluster assignments using DimPlot and SpatialDimPlot. brain_ant &lt;- run_sctype(brain_ant, assay = &quot;SCT&quot;, scaled = TRUE, known_tissue_type=&quot;Brain&quot;, name=&quot;sctype_classification&quot;) ## [1] &quot;Using Seurat v4 object&quot; ## [1] &quot;New metadata added: sctype_classification&quot; figa &lt;- DimPlot(brain_ant, group.by = &quot;sctype_classification&quot;, pt.size = .25) + labs(title = &quot;&quot;) + theme(text = element_text(family = &quot;Helvetica&quot;, size = 10), legend.position = &quot;bottom&quot;, legend.key.spacing.x = unit(0.25, &quot;cm&quot;), legend.key.spacing.y = unit(0.05, &quot;cm&quot;), legend.text = element_text(size = 8)) + coord_fixed(ratio =1) + guides(color = guide_legend(nrow = 3, override.aes = list(size = 2))) leg &lt;- get_legend(figa) figb &lt;- SpatialDimPlot(brain_ant, group.by= &quot;sctype_classification&quot;) + NoLegend() + theme(plot.margin = margin(0, 0, 0, 0)) fig &lt;- ggarrange(figa, figb, nrow = 1, common.legend = TRUE) fig ggsave(filename = paste0(figs_dir, &quot;/Figure_clust_&quot;, fig_num, &quot;.png&quot;), plot = fig, units = &quot;in&quot;, width = two_panel * (7/4), height = two_panel, dpi = 300) fig_num = fig_num + 1 4.6 Saving the data Finally, we save the Seurat object with saveRDS. This file can be loaded again to add other annotations or create more figures without having to repeat the analysis. This same object will also serve as the starting point in subsequent steps. saveRDS(brain_ant, file = paste0(data_dir, &quot;/cluster_mouse_brain.rds&quot;)) sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] Seurat_5.2.1 SeuratObject_5.0.2 sp_2.2-0 HGNChelper_0.8.15 ## [5] dplyr_1.1.4 patchwork_1.3.0 cowplot_1.1.3 ggpubr_0.6.0 ## [9] ggplot2_3.5.1 ## ## loaded via a namespace (and not attached): ## [1] RcppAnnoy_0.0.22 splines_4.4.3 ## [3] later_1.4.1 tibble_3.2.1 ## [5] polyclip_1.10-7 fastDummies_1.7.5 ## [7] lifecycle_1.0.4 rstatix_0.7.2 ## [9] globals_0.16.3 lattice_0.22-5 ## [11] hdf5r_1.3.12 MASS_7.3-64 ## [13] backports_1.5.0 magrittr_2.0.3 ## [15] openxlsx_4.2.8 plotly_4.10.4 ## [17] sass_0.4.9 rmarkdown_2.29 ## [19] jquerylib_0.1.4 yaml_2.3.10 ## [21] httpuv_1.6.15 glmGamPoi_1.18.0 ## [23] sctransform_0.4.1 zip_2.3.2 ## [25] spam_2.11-1 spatstat.sparse_3.1-0 ## [27] reticulate_1.41.0 pbapply_1.7-2 ## [29] RColorBrewer_1.1-3 abind_1.4-8 ## [31] zlibbioc_1.52.0 Rtsne_0.17 ## [33] GenomicRanges_1.58.0 purrr_1.0.4 ## [35] BiocGenerics_0.52.0 GenomeInfoDbData_1.2.13 ## [37] IRanges_2.40.1 S4Vectors_0.44.0 ## [39] ggrepel_0.9.6 irlba_2.3.5.1 ## [41] listenv_0.9.1 spatstat.utils_3.1-2 ## [43] goftest_1.2-3 RSpectra_0.16-2 ## [45] spatstat.random_3.3-2 fitdistrplus_1.2-2 ## [47] parallelly_1.42.0 DelayedMatrixStats_1.28.1 ## [49] codetools_0.2-19 DelayedArray_0.32.0 ## [51] tidyselect_1.2.1 UCSC.utils_1.2.0 ## [53] farver_2.1.2 matrixStats_1.5.0 ## [55] stats4_4.4.3 spatstat.explore_3.3-4 ## [57] jsonlite_1.9.0 progressr_0.15.1 ## [59] Formula_1.2-5 ggridges_0.5.6 ## [61] survival_3.8-3 systemfonts_1.2.1 ## [63] tools_4.4.3 ragg_1.3.3 ## [65] ica_1.0-3 Rcpp_1.0.14 ## [67] glue_1.8.0 SparseArray_1.6.2 ## [69] gridExtra_2.3 xfun_0.51 ## [71] MatrixGenerics_1.18.1 GenomeInfoDb_1.42.3 ## [73] withr_3.0.2 fastmap_1.2.0 ## [75] digest_0.6.37 R6_2.6.1 ## [77] mime_0.12 textshaping_1.0.0 ## [79] colorspace_2.1-1 scattermore_1.2 ## [81] tensor_1.5 spatstat.data_3.1-4 ## [83] tidyr_1.3.1 generics_0.1.3 ## [85] data.table_1.17.0 httr_1.4.7 ## [87] htmlwidgets_1.6.4 S4Arrays_1.6.0 ## [89] uwot_0.2.3 pkgconfig_2.0.3 ## [91] gtable_0.3.6 lmtest_0.9-40 ## [93] XVector_0.46.0 htmltools_0.5.8.1 ## [95] carData_3.0-5 dotCall64_1.2 ## [97] bookdown_0.42 scales_1.3.0 ## [99] Biobase_2.66.0 png_0.1-8 ## [101] spatstat.univar_3.1-1 knitr_1.49 ## [103] rstudioapi_0.17.1 reshape2_1.4.4 ## [105] nlme_3.1-168 cachem_1.1.0 ## [107] zoo_1.8-13 stringr_1.5.1 ## [109] KernSmooth_2.23-26 parallel_4.4.3 ## [111] miniUI_0.1.1.1 pillar_1.10.1 ## [113] grid_4.4.3 vctrs_0.6.5 ## [115] RANN_2.6.2 promises_1.3.2 ## [117] car_3.1-3 xtable_1.8-4 ## [119] cluster_2.1.8.1 evaluate_1.0.3 ## [121] cli_3.6.4 compiler_4.4.3 ## [123] rlang_1.1.5 crayon_1.5.3 ## [125] future.apply_1.11.3 ggsignif_0.6.4 ## [127] labeling_0.4.3 plyr_1.8.9 ## [129] stringi_1.8.4 viridisLite_0.4.2 ## [131] deldir_2.0-4 munsell_0.5.1 ## [133] lazyeval_0.2.2 spatstat.geom_3.3-5 ## [135] Matrix_1.7-2 RcppHNSW_0.6.0 ## [137] sparseMatrixStats_1.18.0 bit64_4.6.0-1 ## [139] future_1.34.0 shiny_1.10.0 ## [141] SummarizedExperiment_1.36.0 ROCR_1.0-11 ## [143] igraph_2.1.4 broom_1.0.7 ## [145] bslib_0.9.0 bit_4.5.0.1 ## [147] splitstackshape_1.4.8 "],["spatially-variable-genes-svgs-discovery-with-spark-x.html", "Chapter 5 Spatially Variable Genes (SVGs) Discovery with SPARK-X 5.1 Importing and Preparing Data 5.2 Running SPARK-X 5.3 Visualizing SVGs 5.4 Saving Data", " Chapter 5 Spatially Variable Genes (SVGs) Discovery with SPARK-X Now that we know our gene expression across the sample, are there genes whose expression varies across the sample in a significant way? This information can be used to study tissue structure, assess spatially-related gene expression, and determine cell-cell communication (although we will look at this specific topic in a later section). There are again many software options for this step using a variety of methods. Some use a Gaussian model (SpatialDE, nnSVG, SOMDE) that provide good results but scale significantly with dataset size. SPARK-X uses non-parametric methods to evaluate the independence of expression of a gene with location on the tissue. This approach requires significantly less RAM, even for large datasets. When finished with this step, we will have data on which genes vary in their expression across the tissue sample and a figure to show as much. As always, we first load the necessary libraries. rm(list = ls()) # This clears your environment of any variables there. We do #this to keep things tidy. library(ggpubr) library(patchwork) library(dplyr) library(SPARK) library(Seurat) # Easy to change variables for our project folder structure data_dir &lt;- &quot;datasets&quot; fig_dir &lt;- &quot;figures&quot; # This sets to the size of figures in inches two_panel = 3.5 one_pnael = two_panel/2 # We can do automatic figure numbering. fig_num = 1 5.1 Importing and Preparing Data Using readRDS we can load in our saved Seurat object. Using GetAssayData and GetTissueCoordinates from Seurat, we can create two variables that contain the raw expression counts and the spatial coordinates respectively. Note if you have not yet removed mitochondrial genes, this should be performed before running this analysis. brain_ant &lt;- readRDS(paste0(data_dir,&quot;/cluster_mouse_brain.rds&quot;)) raw_counts &lt;- GetAssayData(brain_ant, layer = &quot;counts&quot;, assay = &quot;Spatial&quot;) brain_coord &lt;- GetTissueCoordinates(brain_ant)[,c(&quot;x&quot;,&quot;y&quot;)] 5.2 Running SPARK-X With a single sparkx command, spatial information and gene expression are used to determine which gene’s expression differs by tissue area. brain_spark &lt;- sparkx(raw_counts, brain_coord, option = &#39;mixture&#39;) ## ## ===== SPARK-X INPUT INFORMATION ==== ## ## number of total samples: 2779 ## ## number of total genes: 21201 ## ## Running with single core, may take some time ## ## Testing With Projection Kernel ## ## Testing With Gaussian Kernel 1 ## ## Testing With Gaussian Kernel 2 ## ## Testing With Gaussian Kernel 3 ## ## Testing With Gaussian Kernel 4 ## ## Testing With Gaussian Kernel 5 ## ## Testing With Cosine Kernel 1 ## ## Testing With Cosine Kernel 2 ## ## Testing With Cosine Kernel 3 ## ## Testing With Cosine Kernel 4 ## ## Testing With Cosine Kernel 5 5.3 Visualizing SVGs Now that we have a list of spatially variable genes, we can look at them across our tissue sample using the Seurat SpatialFeaturePlot. Here we look at the top 10 most significantly spatially variable genes. top10 &lt;- brain_spark$res_mtest %&gt;% filter(between(adjustedPval, 0, 0.05)) %&gt;% top_n(-10, adjustedPval) fig &lt;- SpatialFeaturePlot(brain_ant, features = c(rownames(top10)), keep.scale = &quot;all&quot;, combine = FALSE) fig[[1]] &lt;- fig[[1]] + theme(legend.title = element_blank()) leg &lt;- ggpubr::get_legend(fig[[1]]) for (i in 1:length(fig)) { fig[[i]] &lt;- fig[[i]] + NoLegend() + labs(title = rownames(top10[i,])) + theme(text = element_text(family = &quot;Helvetica&quot;)) } fig_2 &lt;- wrap_plots(fig, ncol = 4) + plot_spacer() + leg fig_2 ggsave(filename = paste0(fig_dir, &quot;/Figure_svg_&quot;, fig_num, &quot;.png&quot;), plot = fig_2, units = &quot;in&quot;, width = two_panel * (7/4), height = two_panel, dpi = 300) fig_num &lt;- fig_num + 1 5.4 Saving Data We can save our SPARK-X output to an rds file for quick loading to look at specific data or create new figures. saveRDS(brain_spark, file = paste0(data_dir, &quot;/svg_mouse_brain.rds&quot;)) sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] Seurat_5.2.1 SeuratObject_5.0.2 sp_2.2-0 SPARK_1.1.1 ## [5] dplyr_1.1.4 patchwork_1.3.0 ggpubr_0.6.0 ggplot2_3.5.1 ## ## loaded via a namespace (and not attached): ## [1] RColorBrewer_1.1-3 rstudioapi_0.17.1 jsonlite_1.9.0 ## [4] magrittr_2.0.3 spatstat.utils_3.1-2 farver_2.1.2 ## [7] rmarkdown_2.29 ragg_1.3.3 vctrs_0.6.5 ## [10] ROCR_1.0-11 spatstat.explore_3.3-4 CompQuadForm_1.4.3 ## [13] rstatix_0.7.2 htmltools_0.5.8.1 broom_1.0.7 ## [16] Formula_1.2-5 sass_0.4.9 sctransform_0.4.1 ## [19] parallelly_1.42.0 pracma_2.4.4 KernSmooth_2.23-26 ## [22] bslib_0.9.0 htmlwidgets_1.6.4 ica_1.0-3 ## [25] plyr_1.8.9 plotly_4.10.4 zoo_1.8-13 ## [28] cachem_1.1.0 igraph_2.1.4 mime_0.12 ## [31] lifecycle_1.0.4 iterators_1.0.14 pkgconfig_2.0.3 ## [34] Matrix_1.7-2 R6_2.6.1 fastmap_1.2.0 ## [37] fitdistrplus_1.2-2 future_1.34.0 shiny_1.10.0 ## [40] digest_0.6.37 colorspace_2.1-1 tensor_1.5 ## [43] RSpectra_0.16-2 irlba_2.3.5.1 textshaping_1.0.0 ## [46] labeling_0.4.3 progressr_0.15.1 spatstat.sparse_3.1-0 ## [49] httr_1.4.7 polyclip_1.10-7 abind_1.4-8 ## [52] compiler_4.4.3 withr_3.0.2 doParallel_1.0.17 ## [55] backports_1.5.0 carData_3.0-5 fastDummies_1.7.5 ## [58] ggsignif_0.6.4 MASS_7.3-64 tools_4.4.3 ## [61] lmtest_0.9-40 httpuv_1.6.15 future.apply_1.11.3 ## [64] goftest_1.2-3 glue_1.8.0 nlme_3.1-168 ## [67] promises_1.3.2 grid_4.4.3 Rtsne_0.17 ## [70] cluster_2.1.8.1 reshape2_1.4.4 generics_0.1.3 ## [73] gtable_0.3.6 spatstat.data_3.1-4 tidyr_1.3.1 ## [76] data.table_1.17.0 car_3.1-3 spatstat.geom_3.3-5 ## [79] RcppAnnoy_0.0.22 ggrepel_0.9.6 RANN_2.6.2 ## [82] foreach_1.5.2 pillar_1.10.1 stringr_1.5.1 ## [85] spam_2.11-1 RcppHNSW_0.6.0 later_1.4.1 ## [88] splines_4.4.3 lattice_0.22-5 survival_3.8-3 ## [91] deldir_2.0-4 tidyselect_1.2.1 miniUI_0.1.1.1 ## [94] pbapply_1.7-2 knitr_1.49 gridExtra_2.3 ## [97] bookdown_0.42 scattermore_1.2 xfun_0.51 ## [100] matrixStats_1.5.0 stringi_1.8.4 lazyeval_0.2.2 ## [103] yaml_2.3.10 evaluate_1.0.3 codetools_0.2-19 ## [106] tibble_3.2.1 cli_3.6.4 uwot_0.2.3 ## [109] matlab_1.0.4.1 systemfonts_1.2.1 xtable_1.8-4 ## [112] reticulate_1.41.0 munsell_0.5.1 jquerylib_0.1.4 ## [115] Rcpp_1.0.14 globals_0.16.3 spatstat.random_3.3-2 ## [118] png_0.1-8 spatstat.univar_3.1-1 parallel_4.4.3 ## [121] dotCall64_1.2 listenv_0.9.1 viridisLite_0.4.2 ## [124] scales_1.3.0 ggridges_0.5.6 purrr_1.0.4 ## [127] rlang_1.1.5 cowplot_1.1.3 "],["cell-cell-communication-with-cellchat.html", "Chapter 6 Cell-Cell Communication with CellChat 6.1 Importing Data and Setting Computer Options 6.2 Preparing CellChat Object and Database 6.3 Running CellChat 6.4 Visualizing CCC", " Chapter 6 Cell-Cell Communication with CellChat Cells communicate by releasing and receiving molecular messages called ligands. Ligands bind to receptors, often found on cell surfaces. This binding then activates a reaction or pathway that leads to a cell function. Due to decades of research, we know which ligands typically bind to which receptors. Thanks to the scRNA-seq data for our sample we know which cells are expressing either the ligand or receptor in a canonical communication pair. As we also have spatial data available, we can use statistics to predict which cells are most likely communicating with one another based on ligand-receptor gene expression and physical distance from one another. One factor that heavily influences the results of any CCC analysis is the ligand-receptor database used. Indeed the same method can return two drastically different results merely by working from two different ligand-receptor pair lists. CellChat has its own database, CellChatDB, which is manually curated and takes into account things like subunit structure and regulatory pathways. The database is not exhaustive, however, and some ligand-receptor pairs may be missing. Users are able to update the database following the instructions here Another important factor is your annotations previously added in the Clustering step. CellChat will group samples by these annotations to determine which groups are potentially communicating with one another. Be sure your sample is well annotated to obtain the most accurate communication network. As always, let’s load our libraries. rm(list = ls()) library(Seurat) library(CellChat) library(patchwork) data_dir &lt;- &quot;datasets&quot; fig_dir &lt;- &quot;figures&quot; # This sets to the size of figures in inches two_panel = 3.5 one_pnael = two_panel/2 # We can do automatic figure numbering. fig_num = 1 6.1 Importing Data and Setting Computer Options Once again, we can load in the rds of the Seurat object from clustering. No SVG data is saved in the object from the previous section but it is not needed here. This step is very time intensive, potentially requiring several hours on a personal or office machine. Two options can speed up the process, however. R generally reserves only a small amount of RAM for calculations (~500MB) which is easily not enough for this step. We can set an option for the future.globals.maxSize to take advantage of a larger amount of RAM. The exact number will be system-dependent, here we used 32GB of RAM by providing the value 32000 * 1024 ^ 8. We can take advantage of a multicore processor by utilizing the future::plan function to set the number of cores we would like to use for CCC. brain_ant &lt;- readRDS(paste0(data_dir, &quot;/cluster_mouse_brain.rds&quot;)) options(stringsAsFactors = FALSE) options(future.globals.maxSize = 32000*1024^2) # Here we decide to use 32GB RAM out of 48 available. You can set this to whatever number you want. future::plan(&quot;multisession&quot;, workers = 8) # This is the number of cores on which you want this to run. This will depend on how many cores your CPU has. We had 12 available and used 8 here. 6.2 Preparing CellChat Object and Database There is a single command needed to create a CellChat object from a Seurat object. Preparing the database is somewhat more complicated. CellChat has two main databases, one for human and one for mouse. The databases contain a variety of communication modes including secretionary, cell-cell contact, and non-protein signaling. Depending on our cell types and desired research direction, these databases can be subset to focus only on specific interaction lists which may decrease processing time and simplify results. We also need to convert pixels in the H&amp;E image to real-world measurements using the scalefactors_json.json file provided in the Space Ranger output and the spot size of the 10X Visium assay (usually 55μm). A CellChat object can then be created with the aptly named createCellChat function. spatial.locs = GetTissueCoordinates(brain_ant, scale = NULL, cols = c(&quot;imagerow&quot;, &quot;imagecol&quot;)) spatial.locs &lt;- spatial.locs[,c(1,2)] scalefactors = jsonlite::fromJSON(txt = file.path(paste0(data_dir, &quot;/spatial/scalefactors_json.json&quot;))) spot.size = 55 # The current spot size (um) in 10X Visium. This is assay specific and you should double check this value! conversion.factor = spot.size/scalefactors$spot_diameter_fullres spatial.factors = data.frame(ratio = conversion.factor, tol = spot.size/2) d.spatial &lt;- computeCellDistance(coordinates = spatial.locs, ratio = spatial.factors$ratio, tol = spatial.factors$tol) min(d.spatial[d.spatial!=0]) # this value should approximately equal 100um for 10X Visium data ## [1] 84.21583 # create the CellChat object cellChat &lt;- createCellChat(brain_ant, group.by = &quot;sctype_classification&quot;, assay = &quot;SCT&quot;, coordinates = spatial.locs, spatial.factors = spatial.factors) ## [1] &quot;Create a CellChat object from a Seurat object&quot; ## The `meta.data` slot in the Seurat object is used as cell meta information ## Set cell identities for the new CellChat object ## The cell groups used for CellChat analysis are Astrocytes, Dopaminergic neurons, GABAergic neurons, Glutamatergic neurons, Immature neurons, Neural Progenitor cells, Neuroblasts, Oligodendrocytes, Radial glial cells CellChatDB &lt;- CellChatDB.mouse # use all CellChatDB for cell-cell communication analysis. We do not suggest to use it in this way because CellChatDB v2 includes &quot;Non-protein Signaling&quot; (i.e., metabolic and synaptic signaling) that can be only estimated from gene expression data. CellChatDB.use &lt;- CellChatDB # Or optional subsetting # CellChatDB.use &lt;- subsetDB(CellChatDB, search = &quot;Secreted Signaling&quot;, key = &quot;annotation&quot;) # set the used database in the object cellChat@DB &lt;- CellChatDB.use 6.3 Running CellChat Before finding all ligand-receptor pairs, over-expressed genes and interactions are found to infer the cell state-specific communications using identifyOverExpressedGenes and identifyOverExpressedInteractions respectively. If the sequencing depth is shallow, we can use smoothData to smooth genes’ expressions based on neighbors’ validated and high-confidence protein-protein network. If smoothing is used, the parameter raw = FALSE should be added to the computeCommunProb function. cellChat &lt;- subsetData(cellChat) # This step is necessary even if using the whole database cellChat &lt;- identifyOverExpressedGenes(cellChat) cellChat &lt;- identifyOverExpressedInteractions(cellChat, variable.both = FALSE) # project gene expression data onto PPI (Optional: when running it, USER should set `raw.use = FALSE` in the function `computeCommunProb()` in order to use the projected data) #cellChat &lt;- smoothData(cellChat, adj = PPI.mouse) CellChat offers two options for calculating ligand-receptor pairs, triMean which produces fewer but stronger interactions, and truncatedMean to identify weaker signaling. We use our chosen option in computeCommunProb to run the calculation. This function can take several hours to run, especially if using a personal computer instead of sever cluster. Thankfully, a progress bar is conveniently displayed. After our list is obtained, we filter out groups that have only a few cells on which to predict communication with filterCommunication. Next, computeCommunProbPathway will use the ligand-receptor interactions to calculate the communication probability on a signaling pathway and can then aggregate an entire communication network using aggregateNet. As the previous step takes a significant amount of time, it is best to save our analysis as an rds file. cellChat &lt;- computeCommunProb(cellChat, type = &quot;triMean&quot;, distance.use = TRUE, interaction.range = 250, scale.distance = 0.01, contact.dependent = TRUE, contact.range = 84) cellChat &lt;- filterCommunication(cellChat, min.cells = 10) cellChat &lt;- computeCommunProbPathway(cellChat) cellChat &lt;- aggregateNet(cellChat) # That took a long time. Let&#39;s save this object for easy laoding later! saveRDS(cellChat, file = paste0(data_dir, &quot;/cellchat_visium_mouse_cortex.rds&quot;)) 6.4 Visualizing CCC There are many figures and graphs that can be created for CCC analysis. First, using netVisual-circle, we can view communications between each cell group of cells from the clustering step. The vertex and line weights can be set to a number of parameters, including the number of interactions and the strength of the interactions. The same information can alternatively be viewed as heatmaps using “netVisual_heatmap”. # Remove the # from the line below to load your previous CellChat data if you don&#39;t want to rerun the whole thing! cellChat &lt;- readRDS(paste0(data_dir, &quot;/cellchat_visium_mouse_cortex.rds&quot;)) # These aren&#39;t ggplot objects so we have to save them a bit differently png(filename = paste0(fig_dir, &quot;/Figure_ccc_&quot;, fig_num, &quot;.png&quot;), width = two_panel*2, height = two_panel*2, units = &quot;in&quot;, res = 300) par(mfrow = c(1,1), xpd=TRUE) count_plot &lt;- netVisual_circle(cellChat@net$count, vertex.weight = rowSums(cellChat@net$count), weight.scale = TRUE, label.edge= FALSE, margin = c(0,0,0,0)) count_plot dev.off() ## png ## 2 fig_num &lt;- fig_num + 1 netVisual_circle(cellChat@net$count, vertex.weight = rowSums(cellChat@net$count), weight.scale = TRUE, label.edge= FALSE, margin = c(0,0,0,0)) png(filename = paste0(fig_dir, &quot;/Figure_ccc_&quot;, fig_num, &quot;.png&quot;), width = two_panel*2, height = two_panel*2, units = &quot;in&quot;, res = 300) par(mfrow = c(1,1), xpd=TRUE) int_plot &lt;- netVisual_circle(cellChat@net$weight, vertex.weight = rowSums(cellChat@net$weight), weight.scale = TRUE, label.edge= FALSE, margin = c(0,0,0,0)) int_plot dev.off() ## png ## 2 fig_num &lt;- fig_num + 1 netVisual_circle(cellChat@net$weight, vertex.weight = rowSums(cellChat@net$weight), weight.scale = TRUE, label.edge= FALSE, margin = c(0,0,0,0)) png(filename = paste0(fig_dir, &quot;/Figure_ccc_&quot;, fig_num, &quot;.png&quot;), width = two_panel*1.5, height = two_panel, units = &quot;in&quot;, res = 300) par(mfrow = c(1,1), xpd=TRUE) count_map &lt;- netVisual_heatmap(cellChat, measure = &quot;count&quot;, color.heatmap = &quot;Blues&quot;) count_map dev.off() ## png ## 2 fig_num &lt;- fig_num + 1 netVisual_heatmap(cellChat, measure = &quot;count&quot;, color.heatmap = &quot;Blues&quot;) png(filename = paste0(fig_dir, &quot;/Figure_ccc_&quot;, fig_num, &quot;.png&quot;), width = two_panel*1.5, height = two_panel, units = &quot;in&quot;, res = 300) par(mfrow = c(1,1), xpd=TRUE) weight_map &lt;- netVisual_heatmap(cellChat, measure = &quot;weight&quot;, color.heatmap = &quot;Blues&quot;) weight_map dev.off() ## png ## 2 fig_num &lt;- fig_num + 1 netVisual_heatmap(cellChat, measure = &quot;weight&quot;, color.heatmap = &quot;Blues&quot;) If we are interested in a particular signaling pathway, a list of communication probabilities is available in the CellChat object metadata. We can look at the probability of interactions between cell groups involved in the NOTCH pathway with the netVisual_aggregate function. # Visualize pathways cellChat@netP$pathways ## [1] &quot;Glutamate&quot; &quot;GABA-A&quot; &quot;GABA-B&quot; ## [4] &quot;NRXN&quot; &quot;CypA&quot; &quot;ADGRL&quot; ## [7] &quot;PTPR&quot; &quot;CADM&quot; &quot;PTN&quot; ## [10] &quot;PSAP&quot; &quot;LAMININ&quot; &quot;APP&quot; ## [13] &quot;MK&quot; &quot;NCAM&quot; &quot;CNTN&quot; ## [16] &quot;ADGRB&quot; &quot;SLITRK&quot; &quot;EPHB&quot; ## [19] &quot;GAP&quot; &quot;COLLAGEN&quot; &quot;MAG&quot; ## [22] &quot;CLDN&quot; &quot;ApoE&quot; &quot;NEGR&quot; ## [25] &quot;SEMA4&quot; &quot;OPIOID&quot; &quot;SEMA6&quot; ## [28] &quot;GAS&quot; &quot;VTN&quot; &quot;CCK&quot; ## [31] &quot;GRN&quot; &quot;FGF&quot; &quot;FN1&quot; ## [34] &quot;VEGF&quot; &quot;NGL&quot; &quot;EPHA&quot; ## [37] &quot;NTS&quot; &quot;AGRN&quot; &quot;RELN&quot; ## [40] &quot;JAM&quot; &quot;NPY&quot; &quot;2-AG&quot; ## [43] &quot;CDH&quot; &quot;SOMATOSTATIN&quot; &quot;BMP&quot; ## [46] &quot;NECTIN&quot; &quot;CX3C&quot; &quot;Cholesterol&quot; ## [49] &quot;L1CAM&quot; &quot;SEMA3&quot; &quot;UNC5&quot; ## [52] &quot;CSF&quot; &quot;THBS&quot; &quot;SEMA5&quot; ## [55] &quot;WNT&quot; &quot;SPP1&quot; &quot;TENASCIN&quot; ## [58] &quot;NOTCH&quot; &quot;NT&quot; &quot;Desmosterol&quot; ## [61] &quot;ENHO&quot; &quot;PACAP&quot; &quot;PTPRM&quot; ## [64] &quot;SEMA7&quot; &quot;SLIT&quot; &quot;MPZ&quot; ## [67] &quot;Testosterone&quot; &quot;FLRT&quot; &quot;Netrin&quot; ## [70] &quot;TAC&quot; &quot;MIF&quot; &quot;IGF&quot; ## [73] &quot;Adenosine&quot; &quot;ncWNT&quot; &quot;PDGF&quot; ## [76] &quot;SerotoninDopamin&quot; &quot;ESAM&quot; &quot;NRG&quot; ## [79] &quot;VIP&quot; &quot;TGFb&quot; &quot;ADGRG&quot; ## [82] &quot;KIT&quot; &quot;HSPG&quot; &quot;Glycine&quot; ## [85] &quot;ACTIVIN&quot; &quot;AGT&quot; &quot;TULP&quot; ## [88] &quot;MHC-II&quot; &quot;VISFATIN&quot; &quot;CXCL&quot; ## [91] &quot;IGFBP&quot; &quot;GDF&quot; &quot;EGF&quot; ## [94] &quot;VISTA&quot; &quot;DHT&quot; &quot;CRH&quot; ## [97] &quot;RBP4&quot; &quot;LIFR&quot; &quot;PCDH&quot; ## [100] &quot;CSPG4&quot; &quot;NPR1&quot; &quot;OCLN&quot; ## [103] &quot;PECAM1&quot; &quot;ANGPTL&quot; &quot;DHEAS&quot; pathways.show &lt;- c(&quot;NOTCH&quot;) # Circle plot png(filename = paste0(fig_dir, &quot;/Figure_ccc_&quot;, fig_num, &quot;.png&quot;), width = two_panel*1.5, height = two_panel*1.5, units = &quot;in&quot;, res = 300) par(mfrow=c(1,1), xpd = TRUE) # `xpd = TRUE` should be added to show the title pathway &lt;- netVisual_aggregate(cellChat, signaling = pathways.show, layout = &quot;circle&quot;) pathway dev.off() ## png ## 2 fig_num &lt;- fig_num + 1 netVisual_aggregate(cellChat, signaling = pathways.show, layout = &quot;circle&quot;) Finally, we can explore the “centrality” of a network. This tells us which nodes are active in the most pathways and therefore could be more “important”. The calculation is done with “netAnalysis_computeCentrality” and visualized with netAnalysis_signalingRole_network. # Compute the network centrality scores cellChat &lt;- netAnalysis_computeCentrality(cellChat, slot.name = &quot;netP&quot;) # the slot &#39;netP&#39; means the inferred intercellular communication network of signaling pathways # Visualize the computed centrality scores using heatmap, allowing ready identification of major signaling roles of cell groups png(filename = paste0(fig_dir, &quot;/Figure_ccc_&quot;, fig_num, &quot;.png&quot;), width = two_panel*2, height = two_panel, units = &quot;in&quot;, res = 300) par(mfrow=c(1,1)) cent_map &lt;- netAnalysis_signalingRole_network(cellChat, signaling = pathways.show) cent_map ## NULL dev.off() ## png ## 2 fig_num &lt;- fig_num + 1 netAnalysis_signalingRole_network(cellChat, signaling = pathways.show) As we saved the CellChat object after the analysis and have not added to it since then, we do not need to save it again here. sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] patchwork_1.3.0 CellChat_2.1.2 Biobase_2.66.0 ## [4] BiocGenerics_0.52.0 ggplot2_3.5.1 igraph_2.1.4 ## [7] dplyr_1.1.4 Seurat_5.2.1 SeuratObject_5.0.2 ## [10] sp_2.2-0 ## ## loaded via a namespace (and not attached): ## [1] RcppAnnoy_0.0.22 splines_4.4.3 later_1.4.1 ## [4] tibble_3.2.1 polyclip_1.10-7 ggnetwork_0.5.13 ## [7] fastDummies_1.7.5 lifecycle_1.0.4 rstatix_0.7.2 ## [10] doParallel_1.0.17 globals_0.16.3 lattice_0.22-5 ## [13] MASS_7.3-64 backports_1.5.0 magrittr_2.0.3 ## [16] plotly_4.10.4 sass_0.4.9 rmarkdown_2.29 ## [19] jquerylib_0.1.4 yaml_2.3.10 httpuv_1.6.15 ## [22] NMF_0.28 sctransform_0.4.1 spam_2.11-1 ## [25] spatstat.sparse_3.1-0 reticulate_1.41.0 cowplot_1.1.3 ## [28] pbapply_1.7-2 RColorBrewer_1.1-3 abind_1.4-8 ## [31] Rtsne_0.17 purrr_1.0.4 circlize_0.4.16 ## [34] IRanges_2.40.1 S4Vectors_0.44.0 ggrepel_0.9.6 ## [37] irlba_2.3.5.1 listenv_0.9.1 spatstat.utils_3.1-2 ## [40] goftest_1.2-3 RSpectra_0.16-2 spatstat.random_3.3-2 ## [43] fitdistrplus_1.2-2 parallelly_1.42.0 svglite_2.1.3 ## [46] codetools_0.2-19 tidyselect_1.2.1 shape_1.4.6.1 ## [49] farver_2.1.2 matrixStats_1.5.0 stats4_4.4.3 ## [52] spatstat.explore_3.3-4 jsonlite_1.9.0 GetoptLong_1.0.5 ## [55] BiocNeighbors_2.0.1 progressr_0.15.1 Formula_1.2-5 ## [58] ggridges_0.5.6 ggalluvial_0.12.5 survival_3.8-3 ## [61] iterators_1.0.14 systemfonts_1.2.1 foreach_1.5.2 ## [64] tools_4.4.3 sna_2.8 ica_1.0-3 ## [67] Rcpp_1.0.14 glue_1.8.0 gridExtra_2.3 ## [70] xfun_0.51 withr_3.0.2 BiocManager_1.30.25 ## [73] fastmap_1.2.0 digest_0.6.37 R6_2.6.1 ## [76] mime_0.12 colorspace_2.1-1 scattermore_1.2 ## [79] tensor_1.5 spatstat.data_3.1-4 tidyr_1.3.1 ## [82] generics_0.1.3 data.table_1.17.0 FNN_1.1.4.1 ## [85] httr_1.4.7 htmlwidgets_1.6.4 uwot_0.2.3 ## [88] pkgconfig_2.0.3 gtable_0.3.6 registry_0.5-1 ## [91] ComplexHeatmap_2.22.0 lmtest_0.9-40 htmltools_0.5.8.1 ## [94] carData_3.0-5 dotCall64_1.2 bookdown_0.42 ## [97] clue_0.3-66 scales_1.3.0 png_0.1-8 ## [100] spatstat.univar_3.1-1 knitr_1.49 rstudioapi_0.17.1 ## [103] reshape2_1.4.4 rjson_0.2.23 coda_0.19-4.1 ## [106] statnet.common_4.11.0 nlme_3.1-168 cachem_1.1.0 ## [109] zoo_1.8-13 GlobalOptions_0.1.2 stringr_1.5.1 ## [112] KernSmooth_2.23-26 parallel_4.4.3 miniUI_0.1.1.1 ## [115] pillar_1.10.1 grid_4.4.3 vctrs_0.6.5 ## [118] RANN_2.6.2 promises_1.3.2 ggpubr_0.6.0 ## [121] car_3.1-3 xtable_1.8-4 cluster_2.1.8.1 ## [124] evaluate_1.0.3 cli_3.6.4 compiler_4.4.3 ## [127] rlang_1.1.5 crayon_1.5.3 rngtools_1.5.2 ## [130] future.apply_1.11.3 ggsignif_0.6.4 plyr_1.8.9 ## [133] stringi_1.8.4 viridisLite_0.4.2 network_1.19.0 ## [136] deldir_2.0-4 gridBase_0.4-7 munsell_0.5.1 ## [139] lazyeval_0.2.2 spatstat.geom_3.3-5 Matrix_1.7-2 ## [142] RcppHNSW_0.6.0 future_1.34.0 shiny_1.10.0 ## [145] ROCR_1.0-11 broom_1.0.7 bslib_0.9.0 "],["future-directions-and-conclusion.html", "Chapter 7 Future Directions and Conclusion 7.1 Deconvolution 7.2 Conclusion", " Chapter 7 Future Directions and Conclusion 7.1 Deconvolution As this step is optional, it will not be covered here in detail. However, we did want to mention two R packages, RCTD and CARD that are useful for deconvolution. RCTD uses expression profiles from a reference dataset and supervised learning to determine cell type proportions in a spot. CARD uses a gene expression reference and spatial correlation to determine cell type at each spot across a tissue. Either package requires our Seurat object with spatial data and an annotated reference RNA-seq dataset appropriate for the tissue under study. As we have RNA-seq data, analyses typically performed with these data can also be done here. Differential gene expression (DEG) is often performed. We can examine DEG per cell group defined in the clustering step or we can also compare expression in one cluster versus the rest of the cell population in the tissue. Seurat has methods to perform this analysis. Gene set enrichment analysis (GSEA) or a pathway analysis are also possible areas for further study. 7.2 Conclusion Spatial transcriptomics adds another level to RNA analysis, combining gene expression and location information. While we present a simple workflow with mostly default options, there are many nuances to ST analysis. For example, many software has the option to pre-process data before clustering yet there has been evidence that pre-processing can greatly affect analysis outcome. Similarly, normalization can affect deconvolution and it is suggested only raw spatial data should be used. For SVGs and CCC, the list of results returned and their associated statistics greatly depends on the software and database choice respectively. It has been demonstrated in multiple studies that analysis performance is highly dependent on the dataset/software pairing and further algorithm refinement is necessary. Here we focus on one platform and a handful of software for analysis but there are many options available. Visium is only one sequencing platform with other popular options being Slide-seq, MERFISH, seqFISH, Visium HD, and the emerging 10X Genomics Xenium. Each platform has its own pros and cons and offers slightly different analysis options. There are also many software options for each analysis step mentioned here. Again, each has distinct advantages and strengths depending on the dataset and sequencing platform. In the future, we would like to expand this protocol to make it applicable to a wider variety of platforms and analysis options. sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: x86_64-pc-linux-gnu ## Running under: Linux Mint 21 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: America/New_York ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] digest_0.6.37 R6_2.6.1 bookdown_0.42 fastmap_1.2.0 ## [5] xfun_0.51 cachem_1.1.0 knitr_1.49 htmltools_0.5.8.1 ## [9] rmarkdown_2.29 lifecycle_1.0.4 cli_3.6.4 sass_0.4.9 ## [13] jquerylib_0.1.4 compiler_4.4.3 rstudioapi_0.17.1 tools_4.4.3 ## [17] evaluate_1.0.3 bslib_0.9.0 yaml_2.3.10 jsonlite_1.9.0 ## [21] rlang_1.1.5 "]]
